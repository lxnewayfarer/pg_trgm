# PostgreSQL Trigram GIN Index для (I)LIKE запросов
### TL;DR

Краткое резюме для тех, кому лень читать: индекс btree не поможет при оптимизации (I)LIKE запросов типа `WHERE transit_points.address ILIKE '%ул. Пушкина%'`.
pg_trgm индексы хороши для оптимизации (I)LIKE запросов, дают прирост скорости в десятки и сотни раз, но могут потреблять много ресурсов на больших таблицах:

| Число записей в таблице | Время создания индекса        | Место на диске | Время ILIKE запроса без индекса | Время ILIKE запроса с индексом |
| ----------------------- | ----------------------------- | -------------- | ------------------------------- | ------------------------------ |
| ~100к                   | 1541.516 ms (1.5 sec)         | 15 МБ          | 84.988 ms                       | 0.056 ms                       |
| ~1кк                    | 14392.129 ms (14.3 sec)       | 98 МБ          | 989.326 ms                      | 0.204 ms                       |
| ~10кк                   | 137371.369 ms (02 min 17 sec) | 1 ГБ           | 3390.763 ms                     | 0.384 ms                       |


Содержание:
1. Оптимизация (I)LIKE запросов
2. Принцип работы триграммного индекса
3. Процесс исследования
4. GIN vs. GiST
5. Нюансы
6. Выводы
## Оптимизация (I)LIKE запросов

У нас появилась критичная ситуация: запросы к базе стали слишком долгими, когда пользователи запрашивали информацию с различными фильтрами. 
Проведя анализ фильтров, было выявлено, что пользователи в этих долгих запросах, в подавляющем большинстве случаев, используют фильтр contains, который превращается в SQL запрос ILIKE:
```
WHERE transit_points.address ILIKE '%Красноярск%' ESCAPE '~';
```
Итак, выполним EXPLAIN ANALYZE на медленном запросе:
```
EXPLAIN ANALYZE SELECT transit_points.*
FROM transit_points
WHERE transit_points.address ILIKE '%Красноярск%' ESCAPE '~';

 Gather  (cost=1000.00..262162.32 rows=1254 width=82) (actual time=3386.825..3390.509 rows=0 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on transit_points  (cost=0.00..261036.92 rows=522 width=82) (actual time=3372.572..3372.572 rows=0 loops=3)
         Filter: ((address)::text ~~* '%Красноярск%'::text)
         Rows Removed by Filter: 4658889
 Planning Time: 4.138 ms
 JIT:
   Functions: 6
   Options: Inlining false, Optimization false, Expressions true, Deforming true
   Timing: Generation 0.584 ms, Inlining 0.000 ms, Optimization 0.429 ms, Emission 6.572 ms, Total 7.585 ms
 Execution Time: 3390.763 ms
```
В таблице 13976666 записей. Видим, что двум воркерам потребовалось 3,5 секунды, чтобы отфильтровать записи, адрес которых содержит подстроку "Красноярск". Очевидно, нам необходимо сделать индекс. 
Быстрый поиск по интернету плюс общение с ChatGPT привели к тому, что нужно использовать pg_trgm расширение и GIN индекс оттуда. 

Но несколько вопросов остались без ответа перед тем, как это попадет в продакшн:
1. Чем он лучше btree, может быть нам тут btree поможет?
2. Сколько места занимает такой индекс?
3. Насколько он ускоряет запросы?
С официальной документацией можно ознакомиться на сайте PostgreSQL https://www.postgresql.org/docs/current/pgtrgm.html
Но в ней нет ответов на наши вопросы, как и поиск в интернете не дал конкретных цифр. Поэтому было решено провести небольшое исследование и сэкономить кому-то в будущем пару часов жизни.
## Принцип работы триграммного индекса

Для начала, для справки, разберемся, как работает триграммный индекс:
1. При создании индекса, PostgreSQL берет каждую строку в столбце и разбивает её на триграммы. Например, триграммы для `cat` будут  `c`,  `ca`, `cat`, и `at` .
2. Затем PostgreSQL создает индекс, который хранит информацию о том, в каких строках встречаются какие триграммы. Этот индекс похож на огромный список, где для каждой триграммы указаны строки, которые её содержат.
3. Когда вы выполняете запрос на поиск подстроки, PostgreSQL разбивает эту подстроку на триграммы. Например, если вы ищете `"%ell%"`, подстрока `"ell"` разбивается на триграмму `"ell"`.  Затем PostgreSQL использует триграммный индекс, чтобы быстро найти все строки, которые содержат эти триграммы.
4. После выполнения поиска, PostgreSQL берет все строки, найденные с помощью индекса, и проверяет их, чтобы убедиться, что они действительно содержат искомую подстроку.
## Процесс исследования

Ответим на вопросы по порядку. 
Чем он лучше btree? Btree индекс не подходит для решения поставленной задачи. Причем, он не поможет не только в запросах вида `ILIKE '%Иркутск%'`, но и `ILIKE 'Калининград%'`. Планировщик просто игнорирует btree индексы при ILIKE запросах.

Сколько места занимает такой индекс?
Чтобы не нагружать статью большим количеством листингов, для наглядности, рассмотрим процесс исследования на таблице с 14кк записей. Исследования на таблицах с 100к и 1кк записей приведены в таблице в начале статьи. 
Давайте создадим индекс и посмотрим. Еще интересно, сколько времени будет потрачено на его создание. EXPLAIN ANALYZE не работает при создании индексов. Поэтому заходим в psql и включаем настройку, которая будет показывать нам время выполнения запросов:
```
/timing
```
Теперь мы будем видеть время выполнения запросов. Создадим btree индекс на таблице с 14кк записей (он нам нужен для сравнения с trigram):
```
CREATE INDEX executors_lookups_feeds_lookups_on_first_point_address_tmp_btree_idx ON executors_lookups_feeds_lookups (first_point_address);
NOTICE:  identifier "executors_lookups_feeds_lookups_on_first_point_address_tmp_btree_idx" will be truncated to "executors_lookups_feeds_lookups_on_first_point_address_tmp_btre"
CREATE INDEX
Time: 512.817 ms
```
Теперь с помощью функции pg_size_pretty, узнаем сколько места на диске он занимает:
```
SELECT pg_size_pretty(pg_relation_size('transit_points_on_address_btree_idx')) AS size;
  size  
--------
 333 MB
```

Отлично. Пришло время создать gin trigram index:
```
CREATE INDEX transit_points_on_address_gin_trgm_idx ON transit_points USING GIN(address gin_trgm_ops);
CREATE INDEX
Time: 137371.369 ms (02:17.371)
```
Это заняло намного больше времени, чем создание btree индекса. Стоит это учитывать. Посмотрим, сколько места на диске занимает этот индекс. Также, этот индекс занимает 945 МБ на диске. На минуточку, это сопоставимо по размерам с самой таблицей:
```
SELECT pg_size_pretty(pg_relation_size('transit_points')) AS size;
  size   
---------
 1471 MB
```
Но при этом, если взять полный размер таблицы со всеми индексами и тост-данными, то наш trigram index займет примерно 20%, что, в принципе, приемлемо:
```
SELECT pg_size_pretty(pg_total_relation_size('transit_points')) AS size;
  size   
---------
 5738 MB
```
Но самый важный вопрос, насколько он ускоряет запросы? Самое время проверить:
```
Bitmap Heap Scan on transit_points  (cost=757.72..5467.83 rows=1254 width=82) (actual time=0.198..0.198 rows=0 loops=1)
   Recheck Cond: ((address)::text ~~* '%Красноярск%'::text)
   ->  Bitmap Index Scan on transit_points_on_address_gin_trgm_idx  (cost=0.00..757.40 rows=1254 width=0) (actual time=0.135..0.135 rows=0 loops=1)
         Index Cond: ((address)::text ~~* '%Красноярск%'::text)
 Planning Time: 2.735 ms
 Execution Time: 0.384 ms
```
В начале статьи был точно такой же запрос, но без индекса. Два воркера выполнили его seq scan'ом за 3390.763 ms. Здесь же мы видим прирост скорости в, практически, 1000 раз.
## GIN vs. GiST

Почему выбран GIN, а не GiST?
Дело в том, что именно для ILIKE, очень хорош GIN. GiST проигрывает ему. Удалим GIN индекс и создадим GiST:
```
CREATE INDEX transit_points_on_address_gist_trgm_idx ON transit_points USING GIST(address gist_trgm_ops);
CREATE INDEX
Time: 318508.385 ms (05:18.508)
```
Кстати, это заняло в два раза больше времени. И занимает места в 3 раза больше:
```
SELECT pg_size_pretty(pg_relation_size('transit_points_on_address_gist_trgm_idx')) AS size;
  size   
---------
 3374 MB
```
Теперь посмотрим, как GiST справляется с исходной задачей поиска ILIKE:
```
 Bitmap Heap Scan on transit_points  (cost=166.14..4876.24 rows=1254 width=82) (actual time=687.240..687.241 rows=0 loops=1)
   Recheck Cond: ((address)::text ~~* '%Красноярск%'::text)
   ->  Bitmap Index Scan on transit_points_on_address_gist_trgm_idx  (cost=0.00..165.82 rows=1254 width=0) (actual time=687.226..687.227 rows=0 loops=1)
         Index Cond: ((address)::text ~~* '%Уфа%'::text)
 Planning Time: 4.522 ms
 Execution Time: 687.317 ms
```
В результате 687.3 мс у GiST против 0.38 мс у GIN.
Но, как написано в официальной документации, GiST лучше справляется с другими операциями. Например, посчитать для всех значений "похожесть":
```
SELECT t, '_`word`_' <<-> t AS dist
  FROM test_trgm
  ORDER BY dist LIMIT 10;
```
Так что, если задача стоит другая, нежели оптимизация (I)LIKE, то стоит провести собственные исследования.
## Нюансы

У созданного индекса есть несколько нюансов, которые стоит учитывать:
1. Он не ускоряет запросы с оператором сравнения. То есть запрос, содержащий `WHERE name = 'Андрей'`, будет использовать seq scan, не прибегая к индексу trigram. Если у вас  используются и ILIKE, и сравнения, то тогда, для оптимизации, вам придется создать еще и btree индекс.
2. Он не учитывает по-умолчанию символы. То есть если сделать запрос `ILIKE '%||||%'`, то индекс будет проигнорирован планировщиком. Для решения этой проблемы есть несколько подходов. Если проблема связана с языком, то можно попробовать поменять LC_TYPE. Также можно заменять символы перед вставкой в базу.
   При этом, если сравнивать `ILIKE '%ул. Пушкина%'` с `ILIKE '%Пушкина%'`, то запрос чуть замедлится, но не критично, вместо 0.5 мс, будет 1.5 мс. Это связано с тем, что точка будет пропущена при построении триграмм.
## Выводы

Собственно, выводы представлены в таблице в начале статьи. Trigram индексы значительно ускоряют (I)LIKE запросы, давая прирост скорости в сотни раз.
Стоит не забывать про нюансы trigram индексов в Postgres, а также учитывать ресурсоемкость этих индексов.
