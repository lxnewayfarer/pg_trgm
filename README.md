# Результаты оптимизации (I)LIKE запросов в PostgreSQL с помощью триграммных индексов pg_trgm
### TL;DR

Краткое резюме для тех, кому лень читать: индекс btree не поможет при оптимизации (I)LIKE запросов типа `WHERE transit_points.address ILIKE '%Уфа%'`.
pg_trgm индексы хороши для оптимизации (I)LIKE запросов, дают прирост скорости в сотни раз, но могут потреблять много ресурсов на больших таблицах:

| Число записей в таблице | Время создания индекса        | Место на диске | Время ILIKE запроса Seq Scan | Время ILIKE запроса с индексом |
| ----------------------- | ----------------------------- | -------------- | ------------------------------- | ------------------------------ |
| ~100к                   | 1541.516 ms (1.5 sec)         | 15 МБ          | 84.988 ms                       | 0.056 ms                       |
| ~1кк                    | 14392.129 ms (14.3 sec)       | 98 МБ          | 989.326 ms                      | 0.204 ms                       |
| ~10кк                   | 137371.369 ms (02 min 17 sec) | 1 ГБ           | 3390.763 ms                     | 0.384 ms                       |

Если интересно узнать об оптимизации (I)LIKE запросов в PostgreSQL с помощью триграммных индексов детальнее, добро пожаловать под кат. Я попытался написать краткую, но  исчерпывающую статью о том, какие цифры выдает индекс GIN pg_trgm при оптимизации (I)LIKE запросов для тех, кто планирует внедрить это в свое приложение. 

Содержание:
1. Почему pg_trgm
2. Принцип работы триграммного индекса
3. Процесс исследования
4. GIN vs. GiST
5. Нюансы
6. Выводы
## Почему pg_trgm

С ростом числа клиентов, в одном из самых высоконагруженных мест нашего приложения начали замечать долгий отклик базы данных - запросы к базе стали слишком долгими, когда пользователи запрашивали информацию с различными фильтрами. 
Проведя анализ частоты использования фильтров, было выявлено, что пользователи в этих долгих запросах, в подавляющем большинстве случаев, используют фильтр contains, который превращается в SQL запрос ILIKE:
```sql
WHERE transit_points.address ILIKE '%Красноярск%' ESCAPE '~';
```

В таблице на ~10кк записей, двум воркерам потребовалось 3,5 секунды, чтобы отфильтровать записи, адрес которых содержит подстроку "Красноярск". Очевидно, нам необходимо сделать индекс, чтобы ускорить подобные запросы.
Быстрый поиск по интернету плюс общение с ChatGPT привели к тому, что нужно использовать pg_trgm расширение и GIN индекс оттуда. 

Но несколько вопросов остались без ответа перед тем, как это попадет в продакшн:
1. Чем он лучше btree, может быть нам тут будет достаточно btree?
2. Сколько места занимает такой индекс?
3. Насколько он ускоряет запросы?

С официальной документацией можно ознакомиться на сайте PostgreSQL https://www.postgresql.org/docs/current/pgtrgm.html
Но в ней нет ответов на наши вопросы, как и поиск в интернете не дал конкретных цифр, сколько весит, как ускоряет. Поэтому было решено провести небольшое исследование и, возможно, сэкономить кому-то в будущем пару часов жизни.
## Принцип работы триграммного индекса

Для начала, для справки, разберемся, как работает триграммный индекс:
1. При создании индекса, PostgreSQL берет каждую строку в столбце и разбивает её на триграммы. Например, триграммы для `cat` будут  `c`,  `ca`, `cat`, и `at` .
2. Затем PostgreSQL создает индекс, который хранит информацию о том, в каких строках встречаются какие триграммы. Этот индекс похож на огромный список, где для каждой триграммы указаны строки, которые её содержат.
3. Когда вы выполняете запрос на поиск подстроки, PostgreSQL разбивает эту подстроку на триграммы. Например, если вы ищете `"%ell%"`, подстрока `"ell"` разбивается на триграмму `"ell"`.  Затем PostgreSQL использует триграммный индекс, чтобы быстро найти все строки, которые содержат эти триграммы.
4. После выполнения поиска, PostgreSQL берет все строки, найденные с помощью индекса, и проверяет их, чтобы убедиться, что они действительно содержат искомую подстроку.
## Процесс исследования

Ответим на вопросы по порядку. 
Чем он лучше btree? Btree индекс не подходит для решения поставленной задачи. Причем, он не поможет не только в запросах вида `ILIKE '%Иркутск%'`, но и `ILIKE 'Калининград%'`, где сравнение идет по началу строки. Планировщик просто игнорирует btree индексы при (I)LIKE запросах.

Итак, возьмем для теста таблицу с ~10кк записей и выполним EXPLAIN ANALYZE на медленном запросе, чтобы нам было, от чего отталкиваться:
```sql
EXPLAIN ANALYZE SELECT transit_points.*
FROM transit_points
WHERE transit_points.address ILIKE '%Красноярск%' ESCAPE '~';

 Gather  (cost=1000.00..262162.32 rows=1254 width=82) (actual time=3386.825..3390.509 rows=0 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on transit_points  (cost=0.00..261036.92 rows=522 width=82) (actual time=3372.572..3372.572 rows=0 loops=3)
         Filter: ((address)::text ~~* '%Красноярск%'::text)
         Rows Removed by Filter: 4658889
 Planning Time: 4.138 ms
 JIT:
   Functions: 6
   Options: Inlining false, Optimization false, Expressions true, Deforming true
   Timing: Generation 0.584 ms, Inlining 0.000 ms, Optimization 0.429 ms, Emission 6.572 ms, Total 7.585 ms
 Execution Time: 3390.763 ms
```
Здесь мы видим, что два воркера, последовательно проверили (Seq Scan) все записи в нашей таблице, чтобы выполнить фильрацию, и это заняло 3390.763 ms времени.

Чтобы не нагружать статью большим количеством листингов, для наглядности, рассмотрим процесс исследования на таблице с ~10кк записей. Исследования на таблицах с 100к и 1кк записей приведены в таблице в начале статьи. 

Сколько места занимает такой индекс?
Давайте создадим индекс и посмотрим. Еще интересно, сколько времени будет потрачено на его создание. EXPLAIN ANALYZE не работает при создании индексов. Поэтому заходим в psql и включаем настройку, которая будет показывать нам время выполнения запросов:
```
/timing
```
Теперь мы будем видеть время выполнения запросов. Создадим btree индекс на таблице с ~10кк записей (он нам нужен для сравнения с trigram):
```sql
CREATE INDEX transit_points_on_address_btree_idx ON transit_points (address);
CREATE INDEX
Time: 512.817 ms
```
Теперь с помощью функций pg_size_pretty и pg_relation_size, узнаем сколько места на диске он занимает:
```sql
SELECT pg_size_pretty(pg_relation_size('transit_points_on_address_btree_idx')) AS size;
  size  
--------
 333 MB
```

Отлично. Пришло время создать gin trigram index:
```sql
CREATE INDEX transit_points_on_address_gin_trgm_idx ON transit_points USING GIN(address gin_trgm_ops);
CREATE INDEX
Time: 137371.369 ms (02:17.371)
```
Это заняло намного больше времени, чем создание btree индекса. Стоит это учитывать. Посмотрим, сколько места на диске занимает этот индекс. Также, этот индекс занимает 945 МБ на диске. На минуточку, это сопоставимо по размерам с самой таблицей:
```sql
SELECT pg_size_pretty(pg_relation_size('transit_points')) AS size;
  size   
---------
 1471 MB
```
Но при этом, если взять полный размер таблицы со всеми индексами и тост-данными, то наш trigram index займет примерно 20%, что может быть приемлемо:
```sql
SELECT pg_size_pretty(pg_total_relation_size('transit_points')) AS size;
  size   
---------
 5738 MB
```
Но самый важный вопрос, насколько он ускоряет запросы? Самое время проверить:
```sql
Bitmap Heap Scan on transit_points  (cost=757.72..5467.83 rows=1254 width=82) (actual time=0.198..0.198 rows=0 loops=1)
   Recheck Cond: ((address)::text ~~* '%Красноярск%'::text)
   ->  Bitmap Index Scan on transit_points_on_address_gin_trgm_idx  (cost=0.00..757.40 rows=1254 width=0) (actual time=0.135..0.135 rows=0 loops=1)
         Index Cond: ((address)::text ~~* '%Красноярск%'::text)
 Planning Time: 2.735 ms
 Execution Time: 0.384 ms
```
Два воркера выполнили такой же запрос Seq Scan'ом за 3390.763 ms. Здесь же мы видим прирост скорости в, практически, 1000 раз.
## GIN vs. GiST

Почему выбран GIN, а не GiST?
Дело в том, что именно для ILIKE, очень хорош GIN. GiST проигрывает ему. Удалим GIN индекс и создадим GiST:
```sql
CREATE INDEX transit_points_on_address_gist_trgm_idx ON transit_points USING GIST(address gist_trgm_ops);
CREATE INDEX
Time: 318508.385 ms (05:18.508)
```
Кстати, это заняло в два раза больше времени, чем создание GIN индекса. И занимает места в 3 раза больше:
```sql
SELECT pg_size_pretty(pg_relation_size('transit_points_on_address_gist_trgm_idx')) AS size;
  size   
---------
 3374 MB
```
Теперь посмотрим, как GiST справляется с исходной задачей поиска ILIKE:
```sql
 Bitmap Heap Scan on transit_points  (cost=166.14..4876.24 rows=1254 width=82) (actual time=687.240..687.241 rows=0 loops=1)
   Recheck Cond: ((address)::text ~~* '%Красноярск%'::text)
   ->  Bitmap Index Scan on transit_points_on_address_gist_trgm_idx  (cost=0.00..165.82 rows=1254 width=0) (actual time=687.226..687.227 rows=0 loops=1)
         Index Cond: ((address)::text ~~* '%Уфа%'::text)
 Planning Time: 4.522 ms
 Execution Time: 687.317 ms
```
В результате 687.3 мс у GiST против 0.38 мс у GIN.
Но, как написано в официальной документации, GiST лучше справляется с другими операциями. Например, посчитать для всех значений "похожесть":
```sql
SELECT t, '_`word`_' <<-> t AS dist
  FROM test_trgm
  ORDER BY dist LIMIT 10;
```
Так что, если задача стоит другая, нежели оптимизация (I)LIKE, то стоит провести собственные исследования.
## Нюансы

У созданного индекса есть несколько нюансов, которые стоит учитывать:
1. Он не ускоряет запросы с оператором сравнения. То есть запрос, содержащий `WHERE name = 'Андрей'`, будет использовать seq scan, не прибегая к индексу trigram. Если у вас  используются и ILIKE, и сравнения, то тогда, для оптимизации, вам придется создать еще и btree индекс.
2. Он не учитывает по-умолчанию символы. То есть если сделать запрос `ILIKE '%||||%'`, то индекс будет проигнорирован планировщиком. Для решения этой проблемы есть несколько подходов. Если проблема связана с языком, то можно попробовать поменять LC_TYPE. Также можно заменять символы перед вставкой в базу.
   При этом, если сравнивать `ILIKE '%ул. Пушкина%'` с `ILIKE '%Пушкина%'`, то запрос чуть замедлится, но не критично, вместо 0.5 мс, будет 1.5 мс. Это связано с тем, что точка будет пропущена при построении триграмм.
## Выводы

Собственно, выводы представлены в таблице в начале статьи. Trigram индексы значительно ускоряют (I)LIKE запросы, давая прирост скорости в сотни раз.
Стоит не забывать про нюансы trigram индексов в Postgres, а также учитывать ресурсоемкость этих индексов.
